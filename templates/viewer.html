<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>{{ filename }} | Lecture</title>
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;800&display=swap" rel="stylesheet">
  
  <!-- PDF.js Standard Styles -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css">
  
  <style>
    /* 
     * ISOLATED STYLES
     */
    
    body {
      margin: 0;
      padding: 0;
      background-color: #1a1a1a; 
      font-family: 'Inter', sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Topbar Styling */
    .topbar {
      height: 56px;
      background: rgba(10, 10, 10, 0.95);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      padding: 0 16px;
      color: white;
      z-index: 10;
      flex-shrink: 0;
      box-sizing: border-box; 
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      text-decoration: none;
      color: #e5e5e5;
      background: rgba(255, 255, 255, 0.05);
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      transition: background 0.2s;
      border: 1px solid transparent;
      box-sizing: border-box;
      cursor: pointer;
    }

    .btn:hover {
      background: rgba(59, 130, 246, 0.2);
      color: #60a5fa;
      border-color: rgba(59, 130, 246, 0.4);
    }

    .title-area {
      margin-left: 16px;
      display: flex;
      flex-direction: column;
      flex: 1;
      overflow: hidden;
    }
    .file-name {
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .doc-title {
      font-size: 11px;
      color: #a3a3a3;
    }

    .controls {
      display: flex;
      gap: 8px;
    }

    /* PDF Container */
    #viewer-container {
      flex: 1;
      overflow: auto;
      position: relative;
      width: 100%;
      background-color: #1a1a1a;
      display: flex;
      justify-content: center;
    }

    #pdf-wrapper {
      padding: 24px 0;
    }

    /* Page Styles Overrides */
    .page {
      margin: 0 auto 16px auto !important;
      position: relative;
      background-clip: content-box !important;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5);
      border: none !important;
      overflow: hidden; 
    }

    .rp-canvas {
        display: block;
        width: 100%;
        height: 100%;
    }

    /* 
     * CRITICAL TEXT LAYER FIXES 
     */
    .textLayer, .textLayer > span {
        box-sizing: content-box !important;
    }
    
    .textLayer {
        position: absolute !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        opacity: 1 !important;
        mix-blend-mode: normal;
        line-height: 1.0;
        transform-origin: 0 0;
        z-index: 5;
    }

    /* Keep our custom highlight color */
    ::selection {
        background: rgba(59, 130, 246, 0.4);
        color: transparent;
    }
    .textLayer ::selection {
        background: rgba(59, 130, 246, 0.4);
        color: transparent; 
    }

    /* CSS for Eraser Mode */
    .pdfViewer.eraser-mode .annotationLayer {
        z-index: 10 !important; /* Bring above TextLayer (5) */
        cursor: crosshair;
    }
    .pdfViewer.eraser-mode .annotationLayer > div {
            cursor: cell !important; /* Visual cue */
            border: 1px dashed red;  /* Visual cue */
    }
  </style>

  <!-- PDF.js Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
  </script>
</head>

<body>
  <div class="topbar">
    <a href="/" class="btn">
      <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
      Retour
    </a>
    <div class="title-area">
      <div class="file-name">{{ filename }}</div>
      <div class="doc-title">{{ title }}</div>
    </div>
    <div class="controls">
      <button class="btn" id="eraserBtn" onclick="toggleEraser()" title="Mode Gomme: Cliquer pour supprimer des surlignages">
        ðŸ§¹ Gomme: OFF
      </button>
      <button id="zoom-out" class="btn">
        <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M5 12h14"/></svg>
      </button>
      <button id="zoom-in" class="btn">
        <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 5v14M5 12h14"/></svg>
      </button>
    </div>
  </div>

  <div id="viewer-container">
    <div id="pdf-wrapper"></div>
  </div>

  <!-- App Context Menu Logic -->
  <script src="/static/app.js"></script>

  <script>
    const url = "{{ pdf_url }}";

    // Eraser Mode Logic
    let isEraserMode = false;
    function toggleEraser() {
        isEraserMode = !isEraserMode;
        const btn = document.getElementById("eraserBtn");
        // We need to target the container that holds pages with class 'pdfViewer'
        // In our case wrapper holds pages directly, or does it?
        // Let's add class 'pdfViewer' to wrapper or use wrapper directly.
        // Actually, we can just toggle class on body or wrapper.
        // The CSS rule above uses .pdfViewer.eraser-mode
        // Let's rely on wrapper having that class or adding it.
        const wrapper = document.getElementById('pdf-wrapper');
        
        if (isEraserMode) {
            btn.style.background = "#fca5a5"; // Red color
            btn.style.color = "#000";
            btn.textContent = "ðŸ§¹ Gomme: ON";
            wrapper.classList.add("pdfViewer", "eraser-mode");
        } else {
            btn.style.background = "";
            btn.style.color = "";
            btn.textContent = "ðŸ§¹ Gomme: OFF";
            wrapper.classList.remove("eraser-mode");
        }
    }
    let pdfDoc = null;
    let scale = 1.0;
    let isFitToWidth = true;
    
    const container = document.getElementById('viewer-container');
    const wrapper = document.getElementById('pdf-wrapper');

    function getFitWidthScale(viewportWidth) {
      if (!viewportWidth) return 1.0;
      const available = container.clientWidth - 50; 
      const s = available / viewportWidth;
      return s > 0 ? s : 1.0;
    }

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const div = entry.target;
          if (!div.dataset.rendered) {
            renderPageContent(div);
          }
          // Update current page for progress
          currentPage = parseInt(div.dataset.pageNum);
          saveMyProgress();
        }
      });
    }, {
      root: container,
      rootMargin: "500px"
    });

    let currentPage = 1;
    let saveTimeout;

    function saveMyProgress() {
        if (saveTimeout) clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => {
            const scrollTop = container.scrollTop;
            fetch('/api/progress', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    filename: "{{ filename }}", // Jinja template var
                    page_num: currentPage,
                    scroll_top: scrollTop
                })
            });
        }, 1000); // Save after 1 second of inactivity
    }
    
    // Resume
    async function restoreProgress() {
        try {
            const res = await fetch(`/api/progress/{{ filename }}`);
            const data = await res.json();
            if (data && data.scroll_top) {
                console.log("Restoring progress:", data);
                // Ensure layout is ready
                setTimeout(() => {
                    container.scrollTop = data.scroll_top;
                }, 100);
            }
        } catch(e) { console.error("Progress restore failed", e); }
    }

    // State for annotations
    let documentAnnotations = [];

    // Load annotations from server
    async function loadAnnotations() {
        try {
            const res = await fetch(`/api/annotations/{{ filename }}`);
            documentAnnotations = await res.json();
            console.log("Loaded annotations:", documentAnnotations.length);
        } catch(e) { console.error(e); }
    }

    // Listen for new from app.js context menu
    window.addEventListener('annotation-added', async (e) => {
        const { pageNum, rects, color } = e.detail;
        
        // Optimistic UI update (temporary, no ID)
        const pageDiv = document.querySelector(`.page[data-page-num="${pageNum}"]`);
        
        // Save to backend
        try {
            const hRes = await fetch('/api/annotations', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    filename: "{{ filename }}",
                    page_num: pageNum,
                    rects: rects,
                    color: color
                })
            });
            const hData = await hRes.json();
            
            // Reload annotations to get the real object with ID
            await loadAnnotations(); 
            
            // Re-render this page with the REAL ID
            if (pageDiv) {
                 const pageAnns = documentAnnotations.filter(a => a.page_num === pageNum);
                 renderHighlightsForPage(pageDiv, pageAnns);
            }
            
        } catch(err) { 
            console.error(err);
            alert("Erreur sauvegarde highlight"); 
        }
    });

    function renderHighlightsForPage(div, anns) {
        // Create or get annotation layer
        let layer = div.querySelector('.annotationLayer');
        if (!layer) {
            layer = document.createElement('div');
            layer.className = 'annotationLayer';
            layer.style.position = 'absolute';
            layer.style.top = '0';
            layer.style.left = '0';
            layer.style.width = '100%';
            layer.style.height = '100%';
            layer.style.pointerEvents = 'none'; // Allow clicking mostly through
            layer.style.zIndex = '4'; 
            div.appendChild(layer);
        }
        
        // Remove old ones to avoid duplicates if re-rendering? 
        // Ideally we differentiate by ID, but clearing is safer for now.
        layer.innerHTML = "";
        
        const scaleFactor = parseFloat(div.style.getPropertyValue('--scale-factor')) || 1.0;

        anns.forEach(ann => {
            ann.rects.forEach(r => {
                const el = document.createElement('div');
                el.style.position = 'absolute';
                el.style.left = (r.x * scaleFactor) + 'px';
                el.style.top = (r.y * scaleFactor) + 'px';
                el.style.width = (r.w * scaleFactor) + 'px';
                el.style.height = (r.h * scaleFactor) + 'px';
                
                el.style.backgroundColor = ann.color;
                el.style.opacity = '0.4'; 
                el.style.mixBlendMode = 'multiply';
                
                el.style.pointerEvents = 'auto'; // Catch clicks on the highlight itself
                el.style.cursor = 'pointer'; // Show it's clickable
                el.title = "Cliquez pour supprimer";
                
                // Add Delete Handler
                // Note: 'ann.id' might be undefined for optimistic updates until reload
                if (ann.id) {
                    el.onclick = (e) => {
                        e.stopPropagation(); // Prevent other interactions
                        if(confirm("Supprimer ce surlignage ?")) {
                            deleteAnnotation(ann.id);
                        }
                    };
                }
                
                layer.appendChild(el);
            });
        });
    }

    async function deleteAnnotation(id) {
        try {
            await fetch(`/api/annotations/${id}`, { method: 'DELETE' });
            // Reload all to reflect changes
            loadAnnotations().then(() => {
                // Force re-render of visible pages
                document.querySelectorAll('.page[data-rendered="true"]').forEach(div => {
                     const num = parseInt(div.dataset.pageNum);
                     const pageAnns = documentAnnotations.filter(a => a.page_num === num);
                     renderHighlightsForPage(div, pageAnns);
                });
            });
        } catch(e) { alert("Erreur suppression"); }
    }

    async function init() {
      try {
        await loadAnnotations(); // Preload

        pdfDoc = await pdfjsLib.getDocument(url).promise;
        // ... rest of init
        wrapper.innerHTML = "";
        observer.disconnect();

        const p1 = await pdfDoc.getPage(1);
        const v1 = p1.getViewport({scale: 1.0});

        if (isFitToWidth) {
          scale = getFitWidthScale(v1.width);
        }

        for (let i = 1; i <= pdfDoc.numPages; i++) {
          const viewport = v1.clone({scale: scale});
          
          const div = document.createElement("div");
          div.className = "page";
          div.dataset.pageNum = i;
          div.style.width = viewport.width + "px";
          div.style.height = viewport.height + "px";
          div.style.setProperty('--scale-factor', viewport.scale);
          
          wrapper.appendChild(div);
          observer.observe(div);
        }
        
        await restoreProgress();

      } catch (e) { console.error(e); }
    }
    
    // ... event listeners ...

    async function renderPageContent(div) {
      div.dataset.rendered = "true";
      const num = parseInt(div.dataset.pageNum);
      
      const page = await pdfDoc.getPage(num);
      const viewport = page.getViewport({scale: scale});
      
      div.style.width = viewport.width + "px";
      div.style.height = viewport.height + "px";
      div.style.setProperty('--scale-factor', viewport.scale);

      // Canvas ...
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext('2d');
      const outputScale = window.devicePixelRatio || 1;
      
      canvas.width = Math.floor(viewport.width * outputScale);
      canvas.height = Math.floor(viewport.height * outputScale);
      canvas.style.width = viewport.width + "px";
      canvas.style.height = viewport.height + "px";
      canvas.className = "rp-canvas";
      
      div.appendChild(canvas);

      const transform = outputScale !== 1 
        ? [outputScale, 0, 0, outputScale, 0, 0] 
        : null;

      const renderCtx = { 
          canvasContext: ctx, 
          viewport: viewport,
          transform: transform 
      };
      await page.render(renderCtx).promise;

      // Render Annotations BEFORE Text Layer (z-index handled)
      const pageAnns = documentAnnotations.filter(a => a.page_num === num);
      if (pageAnns.length > 0) {
          renderHighlightsForPage(div, pageAnns);
      }

      // Text Layer ...
      const textDiv = document.createElement("div");
      textDiv.className = "textLayer";
      div.appendChild(textDiv);
      
      const textContent = await page.getTextContent();
      pdfjsLib.renderTextLayer({
        textContentSource: textContent,
        container: textDiv,
        viewport: viewport,
        textDivs: []
      });
    }

    // Controls
    document.getElementById('zoom-in').onclick = () => {
      isFitToWidth = false;
      scale *= 1.2;
      init();
    };
    
    document.getElementById('zoom-out').onclick = () => {
      isFitToWidth = false;
      scale /= 1.2;
      init();
    };

    let resizeTimer;
    window.addEventListener('resize', () => {
      if(isFitToWidth) {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(init, 200);
      }
    });

    // Start
    init();
  </script>
</body>
</html>
